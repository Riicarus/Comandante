package com.riicarus.comandante.manage;

import com.riicarus.comandante.exception.CommandNotFoundException;
import com.riicarus.comandante.exception.CommandSyntaxException;
import com.riicarus.comandante.executor.AnalyzedExecutor;
import com.riicarus.comandante.executor.CommandExecutor;

import java.util.LinkedList;
import java.util.List;

/**
 * [FEATURE INFO]<br/>
 * Grammar analyzer. <br/>
 * The detailed grammar --> To doc.
 *
 * @author Riicarus
 * @create 2023-4-13 13:48
 * @since 1.0.0
 */
public class GrammarAnalyzer {

    /**
     * LexicalAnalyzer produces CommandTokens to GrammarAnalyzer.
     */
    private final LexicalAnalyzer lexicalAnalyzer = new LexicalAnalyzer();
    /**
     * The itemManager maintains the registered command items.
     */
    private final CommandItemManager itemManager;
    /**
     * The arguments which is belongs to the current command executor.
     */
    private final List<String> arguments = new LinkedList<>();
    /**
     * AnalyzedExecutors maintains the analyzed executors in one command input.
     */
    private final List<AnalyzedExecutor> analyzedExecutors = new LinkedList<>();
    /**
     * Token stores the current analyzing token generated by LexicalAnalyzer.
     */
    private CommandToken token;
    /**
     * TokenCount points to the current analyzing token's index, used in exception handling.
     */
    private int tokenCount = 0;
    /**
     * PrevItem points to the previous analyzed CommandItem.
     */
    private CommandItem prevItem = CommandItem.ROOT;
    /**
     * PrevMainItem points to the previous analyzed main CommandItem.
     */
    private CommandItem prevMainItem = CommandItem.ROOT;
    /**
     * End refers the current command input's token is all analyzed.
     */
    private boolean end = false;
    /**
     * PrevExecutableType refers the previous executor's type, which is Main, Opt or Arg.
     */
    private PrevExecutableType prevExecutableType;

    public GrammarAnalyzer(CommandItemManager itemManager) {
        this.itemManager = itemManager;
    }

    /**
     * Analyze one command input and returns the analyzed executor list.
     *
     * @param commandStr command input
     * @return analyzed executor list
     */
    public List<AnalyzedExecutor> analyze(String commandStr) {
        resetForNextCommand();
        lexicalAnalyzer.input(commandStr);
        next();
        S();

        return analyzedExecutors;
    }

    /**
     * Iterate next token, get from lexical analyzer.<br/>
     * If the command's tokens is all analyzed, it will not iterate.
     */
    protected void next() {
        token = lexicalAnalyzer.analyzeOne();
        if (token == null) {
            end = true;
        } else {
            tokenCount++;
        }
    }

    /**
     * Reset arguments for next executor.
     */
    protected void resetArguments() {
        this.arguments.clear();
    }

    /**
     * Reset grammar analyzer's variables for next command input.
     */
    protected void resetForNextCommand() {
        this.token = null;
        this.tokenCount = 0;
        this.prevItem = CommandItem.ROOT;
        this.prevMainItem = CommandItem.ROOT;
        this.end = false;
        this.prevExecutableType = null;

        this.analyzedExecutors.clear();
        resetArguments();
    }

    /**
     * Update previous item. If the item is null, it will throw an exception.
     *
     * @param item current prev item
     * @throws CommandNotFoundException runtime exception
     */
    protected void updatePrevItem(CommandItem item) throws CommandNotFoundException {
        if (item == null) {
            throw new CommandNotFoundException("Command not found, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Please check your command definition.");
        }

        prevItem = item;
    }

    /**
     * Update previous main item. If the item is null, it will throw an exception.
     *
     * @param item current prev main items
     * @throws CommandNotFoundException runtime exception
     */
    protected void updatePrevMainItem(CommandItem item )throws CommandNotFoundException {
        if (item == null) {
            throw new CommandNotFoundException("Command not found, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Please check your command definition.");
        }

        prevMainItem = item;
    }

    protected void S() throws CommandSyntaxException {
        try {
            C();
        } catch (CommandNotFoundException e) {
            throw e;
        } catch (CommandSyntaxException e) {
            if (!end) {
                T();
                C();
            } else {
                throw e;
            }
        }

        // M -> End, O -> End, A -> End
        CommandExecutor executor = itemManager.findExecutor(prevItem);
        if (executor != null) {
            analyzedExecutors.add(new AnalyzedExecutor(executor, arguments));
            resetArguments();
        }
    }

    protected void C() throws CommandSyntaxException {
        M();

        boolean endM = false;
        while (!endM && !end) {
            try {
                M();
            } catch (CommandNotFoundException e) {
                throw e;
            } catch (CommandSyntaxException e) {
                endM = true;
            }
        }

        while (!end) {
            Y();
        }
    }

    protected void M() throws CommandSyntaxException {
        if (CommandTokenType.MAIN.equals(token.getType())) {
            CommandItem item = itemManager.getItem(token.getValue(), prevMainItem);
            updatePrevItem(item);
            updatePrevMainItem(item);
            prevExecutableType = PrevExecutableType.MAIN;
            next();
        } else if (CommandTokenType.MAIN_OR_ARGUMENT.equals(token.getType())) {
            CommandItem item = itemManager.getItem(token.getValue(), prevMainItem);
            if (item != null) {
                // Here is main item.
                updatePrevItem(item);
                updatePrevMainItem(item);
                next();
            } else if (!CommandItem.ROOT.equals(prevItem)) {
                A1();
            } else {
                throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                        "Want: MAIN or ARGUMENT, get: " + token.getType() + ". \n " +
                        "Please check your command input, and the pipeline(|) or command linker(&) can only be followed by MAIN.");
            }
        } else {
            throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Want: MAIN or ARGUMENT, get: " + token.getType() + ". \n " +
                    "Please check your command input.");
        }
    }

    protected void Y() throws CommandSyntaxException {
        try {
            O();
        } catch (CommandSyntaxException e) {
            A();
        }
    }

    protected void T() throws CommandSyntaxException {
        if (CommandTokenType.PREFIX_IDENTIFIER.equals(token.getType())) {
            CommandItem prevCommandItem = this.prevItem;
            if (FixedLexicalItemValue.PIPELINE_IDENTIFIER.getValue().equals(token.getValue())) {
                this.prevItem = CommandItem.ROOT;
                this.prevMainItem = CommandItem.ROOT;
                next();
            } else if (FixedLexicalItemValue.COMMAND_LINKER.getValue().equals(token.getValue())) {
                this.prevItem = CommandItem.ROOT;
                this.prevMainItem = CommandItem.ROOT;
                next();
            } else {
                throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                        "Want: PIPELINE(|) or COMMAND_LINKER(&), get: " + token.getType() + ". \n " +
                        "Please check your command input.");
            }

            // M -> T, O -> T, A -> T
            CommandExecutor executor = itemManager.findExecutor(prevCommandItem);
            if (executor != null) {
                analyzedExecutors.add(new AnalyzedExecutor(executor, arguments));
                resetArguments();
            }
        }
    }

    protected void A() throws CommandSyntaxException {
        if (CommandTokenType.PREFIX_IDENTIFIER.equals(token.getType()) && FixedLexicalItemValue.ARGUMENT_QUOTE.getValue().equals(token.getValue())) {
            next();
            A1();
            if (CommandTokenType.PREFIX_IDENTIFIER.equals(token.getType()) && FixedLexicalItemValue.ARGUMENT_QUOTE.getValue().equals(token.getValue())) {
                next();
            } else {
                throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                        "Want: ARGUMENT_QUOTE, get: " + token.getType() + ". \n " +
                        "Please check your command input.");
            }
        } else if (CommandTokenType.MAIN_OR_ARGUMENT.equals(token.getType()) && !CommandItem.ROOT.equals(prevItem)) {
            A1();
        } else {
            throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Want: ARGUMENT_QUOTE, get: " + token.getType() + ". \n " +
                    "Please check your command input.");
        }
    }

    protected void A1() throws CommandSyntaxException {
        if (CommandTokenType.ARGUMENT.equals(token.getType()) || CommandTokenType.MAIN_OR_ARGUMENT.equals(token.getType())) {
            updatePrevItem(itemManager.getItem(FixedLexicalItemValue.ARGUMENT.getValue(), prevItem));
            arguments.add(token.getValue());
            prevExecutableType = PrevExecutableType.ARG;
            next();
        } else {
            throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Want: ARGUMENT, get: " + token.getType() + ". \n " +
                    "Please check your command input.");
        }
    }

    protected void O() throws CommandSyntaxException {
        if (CommandTokenType.PREFIX_IDENTIFIER.equals(token.getType()) && FixedLexicalItemValue.OPT_PREFIX.getValue().equals(token.getValue())) {
            next();
            if (CommandTokenType.PREFIX_IDENTIFIER.equals(token.getType()) && FixedLexicalItemValue.OPT_PREFIX.getValue().equals(token.getValue())) {
                next();
                O2(false);
            } else {
                O1();
            }
        } else {
            throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Want: OPT_PREFIX, get: " + token.getType() + ". \n " +
                    "Please check your command input.");
        }
    }

    protected void O1() throws CommandSyntaxException {
        O2(true);

        boolean isEnd = false;
        while (!isEnd && !end) {
            try {
                O2(true);
            } catch (CommandNotFoundException e) {
                throw e;
            } catch (CommandSyntaxException e) {
                isEnd = true;
            }
        }
    }

    protected void O2(boolean isAlias) throws CommandSyntaxException {
        if (PrevExecutableType.OPT.equals(prevExecutableType) || PrevExecutableType.ARG.equals(prevExecutableType)) {
            // O -> O, A -> O
            CommandExecutor executor = itemManager.findExecutor(prevItem);
            if (executor != null) {
                analyzedExecutors.add(new AnalyzedExecutor(executor, arguments));
                resetArguments();
            }
        }

        if (CommandTokenType.OPT.equals(token.getType())) {
            CommandItem item;
            if (isAlias) {
                item = itemManager.getItemAlias(token.getValue(), prevMainItem);
            } else {
                item = itemManager.getItem(token.getValue(), prevMainItem);
            }
            updatePrevItem(item);

            prevExecutableType = PrevExecutableType.OPT;

            next();
        } else {
            throw new CommandSyntaxException("Command type not feat, near: " + token.toString() + ", token idx: " + tokenCount + ". \n" +
                    "Want: OPT, get: " + token.getType() + ". \n " +
                    "Please check your command input.");
        }
    }

    enum PrevExecutableType {
        MAIN("M"),
        OPT("O"),
        ARG("A");

        private final String value;

        PrevExecutableType(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }
    }
}
